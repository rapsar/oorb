function ff = fffabcnet(v,prm)
%FFFABCNET Find FireFlies Adaptive Background Compensation
%   Remove background and identify bright objects in foreground.
%   Input:  v -- video object, called from v = VideoReader('...')
%           bwth -- binarize threshold, typically 0.1 (0.07 - 0.15)  
%   Ouput:  ff -- firefly structure, see code for details
%
% Raphael Sarfati, 06/2023
% raphael.sarfati@aya.yale.edu

%% processing parameters
% blurring radius for frame processing (default = 1)
blurRadius = 0; %prm.trk.blurRadiusPxl;

% railing background window size, in seconds (default = 1)
bkgrWinWidthSec = prm.trk.bkgrStackSec; 

% threshold for image binarization
bwThr = prm.trk.bwThr;

% Size for batch processing of patches
patchBatch = 1000;

%% intrinsic variables
frameRate = prm.mov.frameRate;
bkgrWinSize = bkgrWinWidthSec*frameRate;
patchSize = ffnet.Layers(1).InputSize;

%% if v is video object -- might not be needed
if isobject(v)
    v{1} = v;
end

%% number of movies
numberMovies = length(v);

%% global frame counter
frameGlobalIdx = 1;

%% initialize first movie
w = VideoReader(v{1});

%% initial background stack
% create background stack or use from previous movie
if nargin == 2
    
    % build initial background stack
    while frameGlobalIdx <= bkgrWinSize
        
        % read frame
        frame = readFrame(w);
        
        % use only green channel
        frame = frame(:,:,2);
        
        % use single precision, for speed
        frame = single(frame);
        
        % add to background stack
        bkgrStack(:,:,frameGlobalIdx) = frame;
        
        % update frame counter
        frameGlobalIdx = frameGlobalIdx+1;
        
    end
    
    % frame index within the stack
    bkgrIdx = 1:bkgrWinSize;
    
elseif nargin == 3
    
    % use stack from previous movie
    bkgrStack = ffprior.bkgrStack;
    bkgrIdx = ffprior.bkgrIdx - max(ffprior.bkgrIdx);
    
else
    error('incorrect number of input arguments')
    
end

% initial background frame
bkgr = mean(bkgrStack,3);

% initialize output
ff.xyt = [];

%% loop through all movies

for i=1:numberMovies

    % start time of processing
    fprintf('\n')
    disp(datetime("now"))
    disp(['movie ' num2str(i) ' of ' num2str(numberMovies)])

    % re-initialize waitbar
    %utl.fastwaitbar reset


    %% re-initialize movie since using readFrame
    if i>1
        w = VideoReader(v{i});
    end

    nFramesApprox = w.Duration*frameRate;
    frameLocalIdx = 1;
    
    % initialize patches array
    patches = [];
    xyt = [];
    %patches = zeros(65,65,3,1000,'uint8');
    %xyt = zeros(1000,3);

    %% processing movie

    % process each frame
    while hasFrame(w)

        % read frame
        frame = readFrame(w);

        % use only green channel
        newFrame = frame(:,:,2);

        % use single precision, for speed
        newFrame = single(newFrame);

        % calculate new bkgr from old and differential earliest/latest frames (for speed)
        [~,m] = min(bkgrIdx);
        bkgr = bkgr + (newFrame - bkgrStack(:,:,m))/bkgrWinSize;

        % update stack with new frame replacing earliest frame
        bkgrStack(:,:,m) = newFrame;
        bkgrIdx(m) = frameGlobalIdx;

        % grab current frame from stack
        currentFrameIdx = frameGlobalIdx;
        f = (bkgrIdx == currentFrameIdx);
        currentFrame = bkgrStack(:,:,f);

        % calculate foreground
        frgr = (currentFrame - bkgr);
        frgr = uint8(frgr);
        if blurRadius > 0.2
            frgr = imgaussfilt(frgr,blurRadius); %slow
        end

        % binarize foreground and analyze connected components
        bw = imbinarize(frgr,bwThr);
        rp = regionprops(bw,newFrame,'Centroid','Area','Eccentricity','MeanIntensity');

        n = length(rp);

        xy = [vertcat(rp.Centroid) repmat(currentFrameIdx,n,1)];
        xy = round(xy); 
        xyt = vertcat(xyt,xy); 
        if ~isempty(xy)
            patches = extractPatches(frame,xy,patches,patchSize);
        end
        
        % classify patches once enough have been extracted
        if size(patches,4) > patchBatch

            xytOut = classifyPatches(xyt,patches,prm.trk.ffnet);

            ff.xyt = vertcat(ff.xyt,xytOut);
            
            % empty arrays
            patches = [];
            xyt = [];
        end
    
        % additional metrics
        % ff.aei{currentFrameIdx} = [vertcat(rp.Area)...
        %     vertcat(rp.Eccentricity)...
        %     vertcat(rp.MeanIntensity)...
        %     repmat(currentFrameIdx,n,1)];
        ff.i(currentFrameIdx) = mean(newFrame,'all');

        % progress
        wb = utl.fastwaitbar(frameLocalIdx/nFramesApprox);

        % update frame counter
        frameGlobalIdx = frameGlobalIdx+1;
        frameLocalIdx = frameLocalIdx+1; 

    end
    
    % new
    % Batch classify all patches
    pred = classify(prm.trk.ffnet, patches);
    % Find indices of patches classified as firefly flashes
    fireflyIndices = logical(double(pred) == 1);  % assuming '1' indicates a positive classification
    % Map indices back to xy coordinates
    xyOut = xyt(fireflyIndices, :);
    % add to list
    ff.xyt = vertcat(ff.xyt,xyOut);

    

end


% %% records all parameters
% ff.n = cellfun(@(x) size(x,1),ff.xy);
% %ff.xyt = vertcat(ff.xy{:}); %xyt coordinates
% %ff.aeit = vertcat(ff.aei{:}); %area & eccentricity for each flash
% ff.log.processed = datetime("now"); %date & time processed
% %ff.mov = get(v{1});
% %ff.bkgrStack = bkgrStack;
% %ff.bkgrIdx = bkgrIdx;
% ff.log.code = fileread([mfilename('fullpath') '.m']);


end

function patchesOut = extractPatches(frame,xy,patchesIn,patchSize)
% extract patches and add to the stack

halfPatchSize = floor(patchSize(1) / 2);

% Ensure coordinates are integers
xy = round(xy);
numXY = size(xy, 1);

% Convert frame to single precision for compatibility with CNN and reduce memory
%frame = single(frame);

% Preallocate the patch array
patches = zeros([patchSize numXY], 'uint8');

% Vectorized extraction of patches using indexing
for i = 1:numXY
    x = xy(i, 1);
    y = xy(i, 2);
    
    % % Define patch boundaries with clamping to image size
    % xmin = max(1, x - halfPatchSize);
    % xmax = min(size(frame, 2), x + halfPatchSize);
    % ymin = max(1, y - halfPatchSize);
    % ymax = min(size(frame, 1), y + halfPatchSize);
    % 
    % % Extract patch and place it in the preallocated array
    % patches(1:(ymax-ymin+1), 1:(xmax-xmin+1), :, i) = frame(ymin:ymax, xmin:xmax, :);

    % Define xi and yi ranges, accounting for 360-degree wrapping on x-axis
    xi = x-halfPatchSize : x+halfPatchSize;
    yi = y-halfPatchSize : y+halfPatchSize;

    % Adjust x indices (repeat edge pixels)
    xi(xi < 1) = 1;
    xi(xi > size(frame, 1)) = size(frame, 1);

    % Adjust y indices for 360-degree wraparound
    yi(yi < 1) = yi(yi < 1) + size(frame, 2);
    yi(yi > size(frame, 2)) = yi(yi > size(frame, 2)) - size(frame, 2);

    % extract patches
    patches(:,:,:,i) = frame(xi, yi, :);
end

patchesOut = cat(4,patchesIn,patches);

end


function xytOut = classifyPatches(xyt,patches,ffnet)

% Batch classify all patches
pred = classify(ffnet, patches);
% Find indices of patches classified as firefly flashes
fireflyIndices = logical(double(pred) == 1);
% Map indices back to xy coordinates
xytOut = xyt(fireflyIndices, :);

end


% %%
% function xyOut = ffnetFilterFrameNO(frame, xy, ffnet)
% % Extract local patches around possible flash locations and classify them using a feedforward neural network
% 
% patchSize = 65;
% numChannels = size(frame, 3);
% numXY = size(xy, 1);
% 
% halfPatchSize = floor(patchSize/2);
% 
% % % Reshape frame into a 2D array where each column represents a pixel
% % pixelData = reshape(frame, [], numChannels)';
% 
% % Preallocate array for patches
% patches = zeros(patchSize,patchSize,numChannels,numXY,'uint8');
% 
% % Round coordinates
% xy = round(xy);
% 
% % Loop over possible flash locations and extract patches
% for i = 1:numXY
%     x = xy(i, 1);
%     y = xy(i, 2);
% 
%     try
%     % Extract local patch around flash location
%     xmin = x - halfPatchSize;
%     xmax = x + halfPatchSize;
%     ymin = y - halfPatchSize;
%     ymax = y + halfPatchSize;
%     patches(:,:,:,i) = frame(ymin:ymax, xmin:xmax, :);
%     %patch = reshape(patch, [], numChannels)';
%     end
% 
% %     % Store patch in array
% %     patches(:, i) = patch(:);
% end
% 
% % Classify all patches using feedforward neural network
% pred = classify(ffnet, patches);
% 
% % Find indices of patches classified as firefly flashes
% fireflyIndices = str2num(char(pred));
% fireflyIndices = logical(fireflyIndices);
% 
% % Map indices back to xy coordinates
% xyOut = xy(fireflyIndices, :);
% 
% end

% function xyOut = ffnetFilterFrame(frame, xy, ffnet)
% % Optimized function to extract local patches and classify using CNN
% 
% patchSize = 65;
% halfPatchSize = floor(patchSize / 2);
% 
% % Ensure coordinates are integers
% xy = round(xy);
% 
% % Convert frame to single precision for compatibility with CNN and reduce memory
% frame = single(frame);
% 
% % Preallocate the patch array in single precision
% numXY = size(xy, 1);
% patches = zeros(patchSize, patchSize, size(frame, 3), numXY, 'single');
% 
% % Vectorized extraction of patches using indexing
% for i = 1:numXY
%     x = xy(i, 1);
%     y = xy(i, 2);
% 
%     % Define patch boundaries with clamping to image size
%     xmin = max(1, x - halfPatchSize);
%     xmax = min(size(frame, 2), x + halfPatchSize);
%     ymin = max(1, y - halfPatchSize);
%     ymax = min(size(frame, 1), y + halfPatchSize);
% 
%     % Extract patch and place it in the preallocated array
%     patches(1:(ymax-ymin+1), 1:(xmax-xmin+1), :, i) = frame(ymin:ymax, xmin:xmax, :);
% end
% 
% % Batch classify all patches
% pred = classify(ffnet, patches);
% 
% % Find indices of patches classified as firefly flashes
% fireflyIndices = strcmp(pred, '1');  % assuming '1' indicates a positive classification
% 
% % Map indices back to xy coordinates
% xyOut = xy(fireflyIndices, :);
% 
% end



